= About Munit Test

The MUnit Test is the basic processor of an MUnit Test Suite. It represents each test scenario you want to try.

image:defining-munit-test.png[defining-munit-test]

[source, xml, linenums]
----
<munit:test name="my-flow-Test" description="Test to verify scenario 1">
</munit:test>
----

//COMBAK: Add Behavior - Validation - Execution


// COMBAK: Update properties loading this based on new specs
In MUnit, you can load properties from the muleÂ­-app.properties file as well as using the context:property-placeholder to load properties from an additional file. +
MUnit provides several ways to override these properties when running MUnit with Anypoint Studio. Properties for the mule-app.properties file are loaded as System properties.

In MUnit, it's mandatory that you write a description in your test. +
Ideally, you should write a useful, representative description of the scenario you are testing. This description displays in the test console before running the test, and also in the reports. +
The more representative the description, the more easy to read and troubleshoot any failures.

[source, xml, linenums]
----
<munit:test name="testingEchoFlow"
    description="We want to test that the flow always returns the same payload as we had before calling it.">
----

image:defining-test.png[defining-test]


There may be scenarios where you need to shoot-down a test. Whether this be because the test is failing or because it has nasty side effects. +
The point is you shouldn't have to comment out the code.

In this case, MUnit allows you to ignore a specific test.

You can ignore any of your tests by adding the ignore boolean to the test definition.

[source, xml, linenums]
----
<munit:test name="my-flow-Test"
      ignore="true"
      description="Test to verify scenario 1">
</munit:test>
----
TIP: Valid values for `ignore` are true and false. If the attribute is not present, the default is false.

image:ignore-test.png[ignore-test]


Sometimes, the only thing you want to validate is that the flow or sub-flow you are testing fails and throws a specific exception, which depends on the business logic being tested. In these cases, MUnit provides a simple way to validate the scenario.

In these cases you can add the attribute expectException, as shown below.

image:expect-exception.png[expect-exception.png]

[source, xml, linenums]
----
<munit:test name="testExceptions" description="Test Exceptions" expectException="">
  <flow-ref name="exceptionFlow"/>
</munit:test>
----


The attribute expectException expects one of the following:

* A literal exception class name (canonical form)
:: When you provide a literal value, it should take the form of the canonical class name_ of the exception that is expected. In these cases, Mule always throws a `MuleMessagingException`. MUnit validates the provided classname if the underlying cause of the `MuleMessagingException` thrown is of the exact same type.
+
[NOTE]
--
When providing exceptions in this way, a subclass of the provided exception does not pass the validation. MUnit looks for the exact same type.
--
+
image:expect-exception-literal.png[expect-exception-literal]
+
[source, xml, linenums]
----
<munit:test name="testExceptions" description="Test Exceptions" expectException="java.lang.RuntimeException">
  <flow-ref name="exceptionFlow"/>
</munit:test>
----

// REVIEW: Rewrite this using DW
* A MEL expression
:: If you choose to use expressions, Mule itself offers a collection of MEL expressions that simplifies the validations of the exceptions thrown.
+
[cols="30,70"]
|===
|Name |Description

|`exception.causedBy(exception_type)`
|Evaluates if the exception was caused by an (instance of) the provided exception type.
Example: `exception.causedBy(org.mule.example.ExceptionType)`

|`exception.causedExactlyBy(exception_type)`
|Evaluates if the exception was caused by the specific exception type provided, discarding all other exception types. For example, if the provided exception type is `NullPointerException`, the expression returns true only if the test returns a NullPointerException.
Example: `exception.causedExactlyBy(org.mule.example.ExceptionType)`

|`exception.causeMatches(<regex>)`
|Checks the cause exception type name matches the provided regex. Supports any java regex plus, prefix, suffix. Example: `exception.causeMatches(org.mule.example.*)`

|===
+
[NOTE]
--
You can combine any expressions as a boolean expression. For example: +
`exception.causeMatches('*') && !exception.causedBy(java.lang.ArithmeticException) &&
!exception.causedBy(org.mule.api.registry.ResolverException)`
--
+
This MEL expression is meant to be used with the expressions listed above, but no verification is performed done to avoid other usages. The only contract being enforced is: The MEL expression should return a boolean value. If true, the test is successful.
+
If the MEL expression returns something that cannot be cast to a Boolean value, the test fails. +
All MEL expression shortcuts, such as `message` or `payload`, are valid. Just bear in mind that if an exception is thrown, the original payload most likely is lost.


If you define that your test expects an exception and none is thrown, the test fails immediately.


== See Also

* link:/munit/v/2.0/munit-test-reference[MUnit Test Reference]
