= Building an External OAuth Provider
:keywords: oauth,raml,ldap

To manage APIs using the link:/api-manager/external-oauth-2.0-token-validation-policy[OAuth 2.0 Access Token Enforcement Using External Provider policy], you first build and deploy a separate OAuth provider application that verifies the validity of OAuth 2.0 credentials. Build an external OAuth provider application on one of the following installations:

* Mule 3.8.0 runtime or later
* API Gateway runtime 2.0 or earlier

These releases employ the link:/mule-user-guide/v/3.8/http-connector[HTTP Connector] whereas earlier runtimes use the link:/mule-user-guide/v/3.8/deprecated-http-transport-reference[deprecated endpoint-based HTTP transport], which is not suitable for use with the provider.

== Building a Provider - Mule Runtime 3.8.x

To build a provider to run on Mule 3.8.x runtime or later, use the following software:

* Anypoint Studio 6.x with Mule Runtime EE 3.8

* Java JDK 1.8

* Maven 3.3.9

You can link:_attachments/customOAuthProviderStudioArchive.zip[download the customOAuthProviderStudioArchive] developed by MuleSoft Consulting to see how a custom AuthenticationProvider can authenticate credentials against any security service. Once authenticated, the provider can return details to the Mule application for passing an access token to the client. You can use this provider with OAuth 2.0 Access Token Enforcement Using External Provider Policy as an alternative to the MuleSoft builtin LDAP functionality. The AuthenticationProvider implementation is a single class in AuthProvider.java. The artifact contains a sample Mule application that demonstrates how the provider works. Use the template to create your own OAuth provider.

*To build the provider template in Mule Runtime 3.8.x:*

. Set up credentials in the Mule EE Repository. Create or add to the Maven `settings.xml` file. For example, on Linux settings.xml is in `~/.m2/settings.xml`:
+
[source,xml,linenums]
----
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                          https://maven.apache.org/xsd/settings-1.0.0.xsd">
...
  <servers>
    <server>
      <id>MuleRepository</id>
      <username>mule.username</username>
      <password>mule.password</password>
    </server>
  </servers>
...
  <profiles>
    <profile>
      <id>Mule</id>
      <activation>
        <activeByDefault>true</activeByDefault>
      </activation>
      <repositories>
        <repository>
          <id>MuleRepository</id>
          <name>MuleRepository</name>
          <url>https://repository.mulesoft.org/nexus-ee/content/repositories/releases-ee/</url>
...
        </repository>
      </repositories>
    </profile>
  </profiles>
  <activeProfiles/>
</settings>
----

. link:https://anypoint.mulesoft.com/login/#/signup[Log into your Anypoint platform] account.
. link:/api-manager/browsing-and-accessing-apis#accessing-your-application-client-id-and-client-secret[Access your client Id and client Secret].
. Download the link:_attachments/customOAuthProviderStudioArchive.zip[customOAuthProviderStudioArchive file].
. Launch Studio, and choose File > Import.
+
The Select dialog appears.
+
. Expand Anypoint Studio and select Anypoint Studio generated Deployable Archive.
. Browse to the customOAuthProviderStudioArchive.zip, and click Finish.
. Enter the client Id and client Secret in *Anypoint Studio* > *Preferences* > *Anypoint Studio* > *Anypoint Platform for APIs*.
. In Project Explorer, select the project name oauth2-cust-provider, right-click, and select *Run As* > *Mule Application with Maven*.
+
The Configure Maven dialog appears.
+
. Enter your Maven installation home directory, for example ``/usr/local/Cellar/maven/3.3.9`, and click *Test Maven Configuration*.
+
Assuming the test was successful, click OK; otherwise, troubleshoot the problem of finding Maven.
+
The console reports that the app deployed. Proceed to testing the provider.

=== Testing the Local Provider

In this procedure, you deploy the provider locally before deploying it to a server to ensure that the provider returns an OAuth2 access code. You encode the client ID and client secret in base64 according to the link:https://tools.ietf.org/html/rfc2617[HTTP Basic Authentication] specification. This specification has been superseded by RFC 7235, but describes HTTP Basic Authentication better than RFC 7235. These following example shows the syntax for encoding these credentials.

*To test the provider:*

. In Studio, select the project folder oauth2-cust-provider and select *Run As* > *Mule application with Maven*.
. Create a base64-encoded string containing the client ID and client secret pair, separated by a colon.
+
`echo '<Client Id>:<Client Secret>' | base64`
+
The encoded pair appears. For example:
+
`NmJlXXXXXXXXXXc0NDZlYmFhNTgzMWQ0NDRhZmNjMmE6MzJkZTE1ZDZZZZZZZZZZZkFEOEJEQUU5QkNGMjc4RDYK`
+
. Request a token using the user name/password credentials specified in the project: user max, password `mule`. Include the encoded string from the last step as the Basic Auth header.
+
----
curl -i -X POST -H "Content-Type: application/x-www-form-urlencoded" -H "Authorization: Basic NmJl...RDYK" -d 'grant_type=password&username=max&password=mule' 'https://localhost:8082/external/access_token' -k
----
+
The output includes the access token. For example:
+
----
HTTP/1.1 200
Content-Length: 250
MULE_ENCODING: UTF-8
Content-Type: application/json; charset=UTF-8
Date: Thu, 13 Oct 2016 22:05:41 GMT

{"access_token":"OFA41VG7i8-7llxOMNVGgNM18W22COFmndyt8bic28qD4ivxtHYqimHduRyNihv9JkZ8nXrdpIOQO-MoxTDUNg","refresh_token":"QNVGc-d26SWrhJtBQ6tsufeJpY4wJEVsimd5zyj_xxFgRBInrp95DTzCmdya6GbK1bpxvERImx76K8Z5nPViLQ","token_type":"bearer","expires_in":1800}
----
. In a browser, enter the following URL, specifying the access token to validate a call to the provider:
+
----
https://localhost:8082/external/validate?access_token=OFA41VG7i8-7llxOMNVGgNM18W22COFmndyt8bic28qD4ivxtHYqimHduRyNihv9JkZ8nXrdpIOQO-MoxTDUN
----
+
The output looks something like this:
+
----
{"expires_in":1460,"scope":"", "client_id":"6be...c2a","username":"max"}
----
+
In the Studio console, the AUTH SUCCESSFUL message appears.

=== Deploying the Provider to a Remote Server

To see use the token to call an API managed by the OAuth2 External Provider Policy, you first have to run the provider on a server. In this procedure, you deploy the provider to CloudHub.

. In Studio, select *File* > *Export*.
+
The Select dialog appears.
+
. Expand the Mule directory, and select *Anypoint Studio Project to Mule Deployable Archive*. Click Next.
+
The Export Mule Project dialog appears.
+
. Browse to a location for saving the archive, name the archive, select *Attach project sources*, and click *Finish*.
+
. In Anypoint Platform, in Runtime Manager, click *Deploy Application*.
+
The Applications page appears.
+
. Configure the following settings:
+
* Application Name--Fill in an application name, for example auth-provider-testing.
* Deployment Target--Accept CloudHub as the deployment target.
* Application File--Choose the archive you exported from Studio.
* Runtime version--Select 3.8.0 or later for this example.
* Worker size--Select a worker size such as 0.1 vCores.
. On the *Properties* tab, add your client_id and client_secret using the following syntax:
+
----
anypoint.platform.client_id=6be08ee8007446ebaa5831d444afcc2a
anypoint.platform.client_secret=32de15d194fd4c7fAD8BDAE9BCF278D6
----
+
image::building-an-external-oauth-2.0-provider-application-df5f1.png[building-an-external-oauth-2.0-provider-application-df5f1]
+
CloudHub requires these credentials. The credentials you entered in Anypoint Studio preferences earlier do not suffice because these credentials are not transferred to CloudHub.
+
. Click *Deploy Application*.

=== Testing the Remotely Deployed Provider

To test the remote provider, use the same curl command that you used for testing the provider you ran locally, except change localhost:8082 to the CloudHub URL `https://auth-provider-testing.cloudhub.io` for the provider.

----
curl -i -X POST -H "Content-Type: application/x-www-form-urlencoded" -H "Authorization: Basic NmJlXXXXXXXXXXc0NDZlYmFhNTgzMWQ0NDRhZmNjMmE6MzJkZTE1ZDZZZZZZZZZZZkFEOEJEQUU5QkNGMjc4RDYK" -d 'grant_type=password&username=max&password=mule' 'https://auth-provider-testing.cloudhub.io/external/access_token' -k
----

The output includes the access token and the expiration time in seconds:

----
{"access_token":"Y9sxvtAc7ytI_yioGAoKhaqOJeEmrnZxgwXhNxYoTJ81WV2OqsLz1DvoT2Kj8Mu4NNZhc9PjBADPSiwumd1tPw","refresh_token":"GNTYxSh8gkHPCVqJYzyQFPyqssypq8aFKIQ_N9UxqfOv271YBsPP_vhpfJck2WZ7fnrVG1IrtSsarf0MBv657g","token_type":"bearer","expires_in":1800}
----

=== Using and Testing OAuth2

In this procedure, you build upon an API Manager tutorial to you create and deploy the JSONPlaceholder service API. You apply the OAuth 2.0 Access Token Enforcement policy to the JSONPlaceholder service API, and then on the portal for the API, request access from an application. You base64-encode the credentials that the application receives to access the JSONPlaceholder service. Using the encoded credentials, you get an access token from the provider and use the token to call the JSONPlaceholder service.

To call the Auth

. Create and deploy the link:/api-manager/designing-your-api#creating-a-raml-1-0-based-api[JSONPlaceholder service API] proxy using API Manager.
. In the RAML of JSONPlaceholder API, include the RAML snippet required by the OAuth 2.0 Access Token Enforcement policy:
+
----
#%RAML 1.0
title: placeholder
version: 1.0.development
baseUri: http://jsonplaceholder.typicode.com
securitySchemes:
  oauth_2_0:
    description: |
      This API supports OAuth 2.0 for authenticating all API requests.
    type: OAuth 2.0
    describedBy:
      headers:
        Authorization:
          description: |
             Used to send a valid OAuth 2 access token. Do not use with the "access_token" query
             string parameter.
          type: string
      queryParameters:
        access_token:
          description: |
             Used to send a valid OAuth 2 access token. Do not use together with the "Authorization"
             header
          type: string
      responses:
        401:
          description: |
            Bad or expired token. This can happen if the user or the API revoked or expired an
            access token. To fix, you should re-authenticate the user.
        403:
          description: |
            Bad OAuth request (wrong consumer key, bad nonce, expired timestamp...). Unfortunately,
            re-authenticating the user won't help here.
    settings:
      authorizationUri: https://auth-provider-testing.cloudhub.io/external/authorize
      accessTokenUri: https://auth-provider-testing.cloudhub.io/external/access_token
      authorizationGrants: [authorization_code, password, client_credentials, implicit]
/users:
  get:
    description: Retrieve a list of all the users
    responses:
      200:
        body:
          application/json:
            example: !include user-example.json
...
----
+
. link:/api-manager/using-policies#applying-and-removing-policies[Apply the OAuth 2.0 Access Token Enforcement] to the API.
+
* Leave Scopes blank.
* In *Access Token validation endpoint url*, use the URL of the provider with the validation path: `https://auth-provider-testing.cloudhub.io/external/validate`
+
image::building-an-external-oauth-2.0-provider-application-8353f.png[building-an-external-oauth-2.0-provider-application-8353f,height=393,width=417]
+
. link:/api-manager/tutorial-create-an-api-portal[Create an API portal] for the API.
. link:/api-manager/browsing-and-accessing-apis#accessing-api-portals[Request access] for a client application to the JSONplaceholder service API.
+
You obtain the client ID and client secret for a requesting application.
+
. Encode the client ID and client secret in base64.
+
`echo '<Client Id>:<Client Secret>' | base64`
+
. Use the encoded credentials to get an access token from the provider.
+
For example, assume the encoded credentials are YmQ2...UY5NkYK. The provider returns the access token:
+
----
curl -i -X POST -H "Content-Type: application/xAuthorization: Basic YmQ2...UY5NkYK" -d 'grant_type=password&username=max&password=mule' 'https://auth-provider-testing.cloudhub.io/external/access_token' -k
---
+
The provider returns the access token:
+
----
HTTP/1.1 200
Content-Type: application/json; charset=UTF-8
Date: Fri, 14 Oct 2016 21:41:44 GMT
MULE_ENCODING: UTF-8
Server: nginx
Content-Length: 250
Connection: keep-alive

{"access_token":"Fy6l_dsnzVFoduMPS3xx6RUeraVDJlWT37ql7ngxFWkERZ9wq4Uy9J1GC57_vzzCGUCGOF0KVDCg6bR2qTQd7A","refresh_token":"Mx0LRTA7_N4TVdg86MXk0dRSIsSLRIcFcI3O9T0T_hy6MPhrjxA797ew-mGD0Nom-1CcTvU4CHOCLnOKSZfpAw","token_type":"bearer","expires_in":1800}
----
+
. In Postman, use the access token to call the JSONPlaceholder service API:
+
* Select the GET operation and enter the URL for the JSONPlaceholder service API to get the list of users: `http://jsonplaceholderapi.cloudhub.io/users`
* On the Headers tab, for the key, select Authorization. For the value, type `Bearer` followed by the access token that the provider returned for the client application.
* Click *Send*.
+
Postman returns the list of users.
+
image::building-an-external-oauth-2.0-provider-application-1da90.png[building-an-external-oauth-2.0-provider-application-1da90]


== Provider Configuration Reference

Key configuration tasks in building a provider are:

* Configure endpoint paths
* Configure scopes
* Apply CORS (optional)
* Expose additional endpoints

=== Configuring Endpoint Paths

One of the key configuration tasks is specifying the following endpoint paths in the mule properties file of the provider:

[source,code,linenums]
----
validate.endpoint.path=validate
authorization.endpoint.path=authorize
access.token.endpoint.path=access_token
----

You also specify one of these endpoints when you apply the policy to the API. You deploy the provider, and then apply the policy to the API, specifying the endpoint of the provider in `Access Token validation endpoint url`:

image::external-oauth-2.0-token-validation-policy-ba3c0.png[external-oauth-2.0-token-validation-policy-ba3c0,height=375,width=404]

=== Configuring Scopes

Another key configuration task is specifying scopes of access using the link:https://tools.ietf.org/html/rfc6749#page-23[scope] request parameter. An OAuth scope is an client configuration for accessing the API to read or write to the resource, for example.

To use API Console to simulate the API, remove the default `READ WRITE` from *Scopes* and specify no scopes using an empty string ("").

Clients can have a subset of scopes that you configure in the Provider. Clients that are configured to have scopes take precedence over default scopes, or no scopes, specified in the provider.

In the config.xml, `defaultScopes` is the attribute that specifies no scopes (an empty string) or a space-separated list of the default scopes a client will have. For example, in this config.xml snippet no scopes are defined:

[source, xml, linenums]
----
    <oauth2-provider:config
        name="oauth2provider"
        providerName="oauth2provider"
        resourceOwnerSecurityProvider-ref="single-user-security-provider"
        clientSecurityProvider-ref="single-user-client-security-provider"
        clientStore-ref="single-user-client-store"

        defaultScopes=""
        supportedGrantTypes="${supported.grant.types}"
        authorizationEndpointPath="${authorization.endpoint.path}"
        accessTokenEndpointPath="${access.token.endpoint.path}"

        enableRefreshToken="true"
        listenerConfig-ref="https.listener" doc:name="OAuth provider module" port="8083" scopes="${scopes}">
    </oauth2-provider:config>
----

The `scopes="${scopes}"` refers to the following blank property: `scopes=`.

=== Applying CORS

To apply the CORS policy, see link:/api-manager/cors-policy[Applying and Editing a CORS Policy].

You may find that you need to implement CORS on your OAuth Provider. The *preFlow* attribute on the OAuth configuration element makes it possible to reference a flow that is processed before anything else. Using this attribute, your OAuth Provider configuration can reference an additional flow that has implemented a CORS configuration, enabling CORS in both the authorize and the access token listeners.

[source, xml, linenums]
----
  <flow name="myCorsFlow">
      <cors:validate publicResource="true"/>
  </flow>

  <oauth2-provider:config
      name="external-oauth2-provider"
      preFlow-ref="myCorsFlow"
      providerName="Ping API"
      resourceOwnerSecurityProvider-ref="single-user-security-provider"
      clientSecurityProvider-ref="single-user-client-security-provider"
      clientStore-ref="single-user-client-store"
      tokenTtlSeconds="86400"
      enableRefreshToken="true"
      listenerConfig-ref="https.listener">
  </oauth2-provider:config>
----

In the above example, the "myCorsFlow" flow configures CORS to allow requests from any origin. This flow is referenced in the OAuth 2.0 Provider via the *preFlow-ref* attribute.

=== Exposing Additional Endpoints

Depending on the OAuth grant type you want to use, the OAuth provider application can expose the following endpoints:

* `/authorize`: configured as an attribute of the `oauth2-provider:config` element
* `/access_token`: configured as an attribute of the `oauth2-provider:config` element
* `/validate`: configured as the address of the HTTP Listener Connector in the flow

[%header,cols="2*"]
|===
|Component |Explanation
|`oauth2-provider:config` |This component encapsulates most of the configurations required to implement OAuth, both for generating tokens or authorization codes, and for validating them. It implicitly exposes two endpoints for assigning authorization codes and tokens. It is then referenced by a matching element in the flow.
|`ss:authentication-manager` |
- Spring bean that defines an authentication manager and provider +
 +
- Validates user credentials

|`api-platform-gw:client-store` |- Store that retains OAuth client-specific information. If the client sends validation credentials in the body or the query of the request, the OAuth Web service provider simply validates the incoming credentials (client ID and client secret) against the content in the clientStore +
- Caches client ID and client secret of valid organization's client applications
|`api-platform-gw:client-security-provider` |Validates client application's credentials.
|`mule-ss:security-manager` |- For configuring link:/mule-user-guide/v/3.7/configuring-the-spring-security-manager[Spring Security Manager] +
- Authenticates resource owners (for example: when the user credentials are validated after the login page). The only situation where this provider is not required, is when the Grant Type is Client Credentials.
|===


== See Also

* link:http://forums.mulesoft.com[MuleSoft's Forums]
* link:https://www.mulesoft.com/support-and-services/mule-esb-support-license-subscription[MuleSoft Support]
