= Key Concepts
:keywords: studio, server, components, connectors, elements, big picture, architecture
:imagesdir: ./_images
:toc: macro
:toc-title:
:toclevels: 1

toc::[]


Mule runtime is the engine that powers Mule applications.
The runtime defines the rules for how event data is handled in an application.

== Mule Event

A Mule event is an object storing information about an _external event_ that triggers a Mule application to execute.

[NOTE]
Do not confuse the event that triggers a Mule application with the Mule event. *The Mule event is created in response to the external event.*

A Mule event is generated by an *Event source*, which is configured to listen for something like an HTTP request, or a change to a database or file.

image::mule-concepts-75c78.png[mule-concepts-75c78]


. An *external event*, represented outside the boxes triggers the *event source*.
. The event source produces a *Mule event*, an object containing the core information processed by the runtime.
. The Mule event travels to each component inside a *flow*.
. Each component interacts in a pre-defined manner with the *Mule message*, which is a package of information about the Mule event.


=== See Also

* link:/#mule-message[Mule Message]
* link:/#event-source[Event Source]
* link:/event-processor[Event Processor]
* link:/#variables[Variables]

[[mule-message]]
== Mule Message

Mule message is the core business information of a Mule event, and is composed of a *payload* - the most important data of the Mule event, and *attributes*, which are metadata for the message payload.

[NOTE]
Large messages or streaming messages can be processed as *records* in a *batch job*.

=== See Also

* link:/#payload[Payload]
* link:/#attributes[Attributes]


[[payload]]
== Payload

The *payload* is the core information of a *Mule message* containing the core data to be processed in the Mule flow.

[[attributes]]
== Attributes

//TODO: are attributes accessible from the application?
The *attributes* are _metadata_ for the *payload*.

[TIP]
Sending a _POST_ HTTP Request with an XML file to a Mule application generates a *Mule Message* whose *attributes* are the HTTP headers, and its *payload* is the XML file being POSTed.

== Variables

// TODO: Require more context around variables.
In Mule terms, variables are used to hold metadata for the Mule event. These can be defined and referenced in your application.

Variables can store metadata resulting from different *operations* performed throughout the application or to add metadata to a processing *Mule event*.

// TODO: Would it make sense to show Event Context (ExecutionContext) ?
// === Event Context
//The ExecutionContext that does not change within the scope of a single request and has the orginalPayload, MEP, credentials as well as reference to txContext and muleContext.

== Component

Mule uses *components* to _compose_  Mule applications and determine their logic to process the *Mule event*.

The generic categores of *components* in a Mule application are:

* link:/#flow[Flow]
* link:/#event-source[Event Source]
* link:/#event-procesor[Event Processor]

[[flow]]
== Flow

A flow is a sequence of components that handle the *Mule Event*. A flow itself can be thought of as a component, but typically we don't refer to a flow as such.

When you link together several individual elements to handle the receipt, processing, and eventual routing of a *Mule Event* you are essentially composing a flow.

Typically, a *flow* starts with an event source. The event source is triggered, a *Mule event* is created.

Event Processors transform, enrich and filter the Mule event.

=== See Also

* link:/#event-source[Event Source]
* link:/#event-processor[Event Processor]

[[event-source]]
== Event Source

An *Event Source* waits for an event that triggers it. Event Source performs logic to define the event's Mule message. It forwards the Mule event and message to the next *Component* in the flow, along with some metadata around the received event conforming the *Mule Event* that the *flow* will process.

Examples of *event sources*:

* *HTTP Listener*
* *File Directory Watcher*

=== See Also

* link:/#module[Module]

[[event-processor]]
== Event Processor

Event Processors are the components used to conduct backend processes for specific business logic around the *Mule event*.

They are grouped based on the actions they facilitate:

* link:/#operation[Operation]
* link:/#scope[Scope]
* link:/#router[Router]
* link:/#transformer[Transformer]
* link:/#module[Module]

[[operation]]
== Operation

*Operations* apply specific actions in the Mule application. They can be used to generate a request to an external source, or to point to local resources within an application's package structure.

Examples of *operations* are any supported by a module, like the Database Connector. Most connectors are now based on the operation model.

=== See Also

* link:/#module[Module]

[[scope]]
== Scope

*Scopes* can wrap *operations* to constrain behavior on data within a *flow*. They can be used to define the frequency at which to perform an operation, or to specify that a certain *operation* should be applied asynchronously.

// TODO: is async a scope or a router?
Some examples of scopes are *Poll* and *Async*.

//TODO: Can I use a scope to enrich a message payload?

[[router]]
== Router

*Routers* can be used to direct, resequence, split and aggregate Mule events.

Some examples of routers are _Splitter_, _Scatter-gather_ and _Resequencer_.

[[transformer]]
== Transformer

A transformer is a *component* that changes the *payload* of a *Mule message*.

Some examples of *transformers* are _Object to XML_ and the _Object to String_ transformers.

[CAUTION]
Transformers are included in Mule 4 Beta for compatibility reasons. They will be deprecated for future releases. +
Transformation should be carried by DataWeave expressions.

[[module]]
== Module

A module is a package of functionality for Mule. It can combine *Event sources*, perform *operations* and offer a number *configurations*, each of which may support a subset of operations.

Each *Module* can extend the runtime capabilities allowing users to configure connections to different services almost automatically.

// TODO: Modules to use to validate

// TODO: Determine if this is technically accurate
Importantly, *modules* don't have to have any Mule-specific code; they can simply be POJOs, Spring beans, Java beans, Groovy scripts, or web services containing the business logic for processing data. Components can even be developed in other languages such as Python, JavaScript, Ruby, and PHP. Mule’s catalog of *components* support the most commonly used Enterprise Integration Patterns.

Some examples of *modules* are the _SalesForce Connector_ and the _SAP Connector_.

== Configurations

Global configurations for a specific *module* are typically defined for a connector


== DataWeave

Dataweave is the primary language used for formulating expressions in Mule, allowing you to access, manipulate, and use information from the message and its environment. 

At runtime, Mule evaluates expressions while executing a flow to:

* Extract information from the Mule event.
* Restructure or manipulate any part of the Mule event.
// TODO: Define if DW can be used to filter muleEvents.
* Define a filter, to allow certain *Mule events* to continue to be processed in a *flow* based on certain criteria.
* Set or manipulate a value in the message attribute, the payload, or a variable.
* Perform an operation on information in the Mule event, application, Mule instance, or server.
