= DataWeave Scripts

DataWeave scripts are divided into two sections that are delimited by a three-dash separator (&#45;&#45;&#45;). You can create these scripts in a Transform component.

// TODO?: or save them in a `.dwl` file that you import into a Mule app from Studio.

.DataWeave Script
[source, dataweave, linenums]
----
// Header example:
%dw 2.0
output application/xml
---
// Body example:
{
  user: {
    name: payload.user_name,
    lastName: payload.user_lastName
  }
}
----

The DataWeave script can handle input that is structured something like this:

.Input
[source,json,linenums]
----
 {
  "user_name": "Annie",
  "user_lastName": "Point"
 }
----

The script transforms the JSON input and into XML output like this:

.Output
[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<user>
 <name>Annie</name>
 <lastName>Point</lastName>
</user>
----

== DataWeave Header

The DataWeave header contains the directives, which define high-level information about your transformation:

* DataWeave version: Required.
+
Example: `%dw 2.0`
+
* Output type: Required. The mime type that for the script to output.
+
Example: `output application/xml`
Note that only one output type can be specified. See <<dataweave-formats, DataWeave Formats>> for a list of valid mime types.
+
* Namespaces: Used to import a namespace.
+
Example: `ns msg http://www.mulesoft.com/anypoint/SOA/message/v1.0`
+
* Global variables: Define constants and can be referenced throughout the body of the DataWeave script.
+
.Example
[source, dataweave, linenums]
----
%dw 2.0
var conversionRate=13.15
output application/json
---
{
 price_dollars: payload.price,
 price_localCurrency: payload.price * conversionRate
}
----
+
* Functions: For creating custom functions that can be called from within the body of the script.
+
.Example
[source, dataweave, linenums]
----
%dw 2.0
output application/json
var toUser = (user) -> {firstName: user.name, lastName: user.lastName}
---
{
 user: toUser(payload)
}
----
// *Input type, for example, `%input payload application/xml`

== DataWeave Body

The DataWeave body contains the expression that generates the output structure. Note that the mime types of the input and output data are always normalized into canonical DataWeave model prior to transformation. So for example, XML (`application/xml`) input is normalized to DataWeave before it is transformed and output to JSON (`application/json`).

[TIP]
To visualize the canonical DataWeave model of your data, you can set the output type of your transform to `application/dw`. Your transform then outputs your data as a DataWeave expression, which resembles a JSON object.

// TODO: NEED MORE INFO HERE... show XML vs DW vs JSON

== DataWeave Output

The data model of the produced output could consist of these data types:

* Simple Values: Strings and numbers, for example: `Some String`, `18`.
* Arrays: A sequence of comma separated values, for example: `1, 2, 3`. The values can be any supported data type.
* Objects: A collection of key-value pairs, for example: `{"key": "some value"}`. The values can be any supported data type.
// TODO: ARE THERE ANY OTHERS?


== See Also

* link:dataweave-types#functions-and-lambdas[Functions and Lambdas]
