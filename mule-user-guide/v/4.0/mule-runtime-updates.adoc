= Mule Runtime v4 Updates
:keywords: news, updates, mule ESB, mule runtime, 4.0, Mule 4.0, Mule 4.0 for mule 3 developers, what's new Mule 4

Mule 4 introduces significant changes from previous versions. +
Its simplified language and reduced management complexity allows you to speed up the on ramping process and deliver applications faster.

If you are familiar with the concepts of the previous versions of the runtime, check the sections below to learn what's changing in Mule Runtime v4.0:

== Simplified Event and Message Model

Mule 4 includes a simplified Mule Event and Message model. In Mule 4, Flows are triggered by an Event. An Event has a Message and variables associated with it. A Message is composed of a payload and its attributes (metadata, such as files size). Variables hold arbitrary information, such as Messages, payload data, or attributes.

All other concepts around the former Mule Event object have been deprecated:

* There are no more _inbound_, _outbound_ or _session_ properties.
* To send data across protocol barriers like session properties did, you must explicitly specify what parameters you want to send. For example with the HTTP request, you can specify output headers.
* All information around the Mule event is now exposed through variables, allowing you to completely manage the Mule event.

The steps in the flow that handle Mule events, are now referred to as components. Components that act on a Mule Event are event processors, and every processor that defines an operation to apply to the Mule event are known as operations. Once operations execute, they replace the Message on the Event with a new one. To save the previous message, you must store it in a variable

== DataWeave 2.0: the new Mule Expression Language

In Mule 3, users had to contend with learning both the Mule Expression Language (MEL) and DataWeave. MEL forces users to convert their payloads from binary data, such as XML or JSON documents, into Java objects, so they can write expressions which access that data, for example when routing it to a specific location.

In *Mule 4*, DataWeave is now the default expression language. Combined with the built-in streaming capabilities, this simplifies many common tasks:

* Events can be routed based on payload data, without first needing to convert to Java objects.
* Binary data can easily be queried from an expression anywhere in your flow, for example, when logging.
* Larger than memory access to data happens transparently.

DataWeave 2.0 also features many improvements:

* Language simplifications. Everything is now a function.
* DataWeave scripts can now be packaged and reused, via the new imports and modules features.
* Support for multi-line comments.
* Support for calling static Java functions directly from DataWeave.

== Streaming management

// TODO - link to streaming section in docs
*Mule 4* now automatically handles data streams for users. This greatly simplifies working with data in Mule, because:
* Data can be read multiple times or accessed randomly (with the DataWeave expression language) without side effects
* Data can be sent to multiple places, without the user caching that data in memory first
* Users can transparently access larger than memory data

== Non-Blocking, Self-Tuning Runtime

*Mule 4* includes a new execution engine that is based on a _non-blocking_ runtime. This is a *task-oriented* execution model allowing the user to take advantage of non-blocking IO calls and avoiding performance problems due to incorrect processing strategies configurations.

As a result of this new engine, users no longer have to configure exchange patterns. Instead, flows always function synchronously. If a user wishes to achieve asynchronous (i.e. fire and forget) type patterns, they can use the <async> processor.

Each Mule event processor can now inform the runtime if it is a CPU intensive, CPU light, or IO intensive operation. This will in turn help Mule self-tune for different workloads dynamically, removing the need for customers to manage thread pools manually. As a result, *Mule 4* removes complex tuning requirements to achieve optimum performance.

== Enrich Events directly from connectors/modules
For any given module operation, it is now possible to define a _target_, which saves the result in a variable:

[source,XML,linenums]
----
<httpn:request target="myVar" config-ref="requestConfig" method="GET" url="http://mulesoft.com"/>
----
This saves the Mule message in the `myVar` variable to be accessed later. This reduces flow complexity by removing the need for enricher.

== Simplified Connectors and Modules Experience

Mule 4 introduces more consistency around connectors/modules, creating one unified experience for how to interact with Mule components. Transports have been completely replaced by Mule Modules. Connectors/Modules can be created and managed using the Mule SDK, which provides a single way to extend Mule.

// COMBAK: Smart connectors are not going to be available for BETA
// Introducing Smart Connectors: Modules designed using XML to manipulate connections. +
// Users can define the module, set configurations and define operations that can later be invoked in the mule application to manipulate connections.

// REVIEW: Need confirmation about private flows going away.

== Simplified Error Handling and new Try Scope

*Mule 4* includes a simplified way to manage errors. Instead of dealing with Java Exceptions directly, there is now an Error concept built in directly to Mule. Furthermore, Mule Modules declare what Errors may occur for any given operation. This makes it easy for users to discover possible errors at design time and catch them.

Errors may be caught via error handlers. Errors can now be caught based on both type, and arbitrary expressions. Error handlers replace exception strategies. Errors can either be caught, so that the flow can keep processing, or they can be re-propgated. 

There is also a new _Try_ scope, This allows users to catch errors in the middle of a flow, without having to create a new flow, specifically to catch that error.

== Mule API

Mule 4.0 includes new, well defined APIs. These make it easier to extend Mule and provide clarity to developers on what the proper extension points are.

The runtime exposes 3 main APIs that allow you to build on top and extend the runtime capabilities:

* Core API: Mule message
* Extensions API: APIs which allow users to create modules, message processors, transformers, etc. which extend the runtime.
* Tooling API: All DataSense metadata and propagation is now part of the runtime, and can be accessed as part of the tooling API, which is bundled with the Mule Agent.

== Classloader Isolation for Mule runtime, Applications, and connectors

Mule 4.0 loads each Module in its own classloader, isolating the modules from internal Mule code. +
Given that applications are no longer dependent from internal Mule changes, users are able to upgrade their runtime version without breaking compatibility with other modules.

All modules are distributed outside the runtime, meaning that Mule 4.0 does not include any _connector_ by default.

== Compatibility Module

To help you migrate to Mule 4.0, there is a new compatibility module which provides backward compatibility for a number of features from Mule 3, including:
* Transports: HTTP, JMS, Database
* Mule Expression Language
* set-payload, set-variable, set-property, remove-property, copy-properties
* poll

// TODO link to the migration guide