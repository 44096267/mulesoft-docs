= About Streaming in Mule 4.0

Data streams cannot be consumed more than once and cannot be consumed at the same time. +
For example, if a JSON payload is transferred from an Event Source to a File connector with a write operation, the stream would be consumed by the File connector, and the payload would not be available for being processed by any other module.

image::streaming-about-49d23.png[]

In a Mule 3.x application, this flow results in the first file getting written correctly, and the second getting created with an empty content. +
However, if this payload is transferred from an Event Source to a Logger component and later you attempt to write this payload to a file the payload would get logged and written to the file as you'd expect.

image::streaming-about-bd915.png[]

This happens because the logger component consumes the stream loading it into memory. By the time the message reaches the File Connector, the stream is loaded into memory. Keep in mind that if the content is too big, you risk your app’s stability by running out of memory. +
Trying to do the same using a scatter-gather component, this application fails because your streamed content cannot be concurrently consumed by two different threads.

image::streaming-about-6af9b.png[]

Mule 4.0 handles data streaming using Repeatable Streams. As the component consumes the stream, Mule saves its content into a temporary buffer.

This all happens automatically, so no special configuration is needed from your end.

Repeatable Streams enable you to:

* Read a stream more than once.
* Have concurrent access to the stream.

When streaming, Mule 4.0 feeds each component that receives a type of stream from the temporary buffer, making sure that each component receives the full stream, regardless of how much of the stream was already consumed by any prior component. +
Repeatable streams also allow concurrent access, so any number of concurrent threads can safely access the streamed data.

// By default, the in-memory buffer size is 512 KB. Although this size for the in-memory buffer proved to be performant for most scenarios, you can configure the buffer size to any custom value.

This way, a Mule 4.0 application can transfer the JSON payload from an HTTP listener, write it to a file using a File Connector, and then could use another File connector to write the JSON in another file. +
It could also process the JSON payload through a Scatter-Gather router and allow the stream to be processed by different processor chains simultaneously.

You can configure how Mule handles the repeatable stream using different streaming strategies:

// COMBAK: Add Examples and Add Screenshots.

=== File Stored Repeatable Stream

:: This is the default streaming strategy in Mule Runtime Enterprise Edition.
+
[NOTE]
--
This option is only available on Mule EE
--
+
It initially uses an in-memory buffer size of 512 KB. If the stream is larger than that, it creates a temporary file on your disk to store the contents without overflowing your memory.
+
When you know you need to deal with large or small files, you can change the buffer size to optimize performance. +
Configuring a bigger buffer size increases performance by avoiding the number of times the runtime needs to write the buffer to your disk., but it also limits the number of concurrent requests your application can process. +
The same way, configuring a smaller buffer size saves you memory load. You can even set the buffer's unit of measurement, so you don't have to go through unit conversions.
+
For example, if you know that you are going to read a file that's always around 1 MB size, you can configure a 1 MB buffer:
+
[source,xml,linenums]
----
<file:read path="bigFile.json">
  <repeatable-file-store-stream
    InMemorySize="1"
    bufferUnit="MB"/>
</file:read>
----
+
Or if you know you are always processing a file no bigger than 10 KB, you can save memory:
+
[source,xml,linenums]
----
<file:read path="smallFile.json">
  <repeatable-file-store-stream
    InMemorySize="10"
    bufferUnit="KB"/>
</file:read>
----
+
Based on performance test, the default 512 KB buffer size configuration of this strategy does not significantly impact performance in most scenarios. +
You need to run tests and find the proper buffer size configuration that fits your needs.

=== In Memory Repeatable Stream

:: This configuration is the default for Mule Runtime Community Edition. +
It uses a default configured buffer size of 512 KB. If the stream is larger than that, the buffer is expanded to a default increment size of 512 KB until it reaches the configured maximum buffer size. If the stream exceeds this limit, the application fails. +
+
You can customize this behavior by setting the initial size of the buffer, the rate at which the buffer increases, the maximum buffer size, and the measurement unit. +
For example, these settings configure an in-memory repeatable stream with a 512 KB initial size, which grows at a rate of 256 KB and allows up to 2 MB of content in memory:
+
[source,xml,linenums]
----
<file:read path="exampleFile.json">
  <repeatable-in-memory-stream
    initialBufferSize="512"
    bufferSizeIncrement="256"
    maxInMemorySize="2000"
    bufferUnit="KB"/>
</file:read>
----
+
Based on performance test, the default 512 KB buffer size, and 512 KB increment size configuration of this strategy does not significantly impact performance in most scenarios. +
You need to run tests and find the proper buffer size and size increment configuration that fits your needs.

=== Non Repeatable Stream

:: This strategy disables repeatable streams. It allows you to use the plain old streams, where an input stream can only be read once and does not allow concurrent access from concurrent threads.
+
For example, if you don't need to set a buffer for your stream, you can set a non-repeatable streaming strategy:
+
[source,xml,linenums]
----

<file:read path="exampleFile.json">
  <non-repeatable-stream />
</file:read>

----
+
This strategy is not suitable for scenarios in which the stream needs to be consumed more than once.

Every component in Mule 4.0 that returns an InputStream or a Streamable collection supports repeatable streams.
Some of these components are:

* File Connector
* FTP Connector
* DataBase Connector
* HTTP Connector
* Sockets

A similar scenario happens when an Anypoint Connector is configured to use auto-paging. Mule 4.0 automatically handles the paged output of the connector using Repeatable Auto Paging. +
Mule sets a configurable in-memory buffer that by default, is configured to hold up to 500 objects. Mule measures the buffer size using instance counts. +
When calculating the in-memory buffer size for repeatable auto-paging, you need to estimate how much memory space each instance takes to avoid running out of memory.

As with repeatable streams, you can use different strategies to configure how Mule handles the repeatable auto paging:

=== Repeatable File Store Iterable

:: This configuration is the default for Mule Runtime Enterprise Edition. +
It uses a default configured in-memory buffer of 500 objects. If your query returns more results than the buffer size, Mule serializes those objects and writes them to your disk. +
You can configure the number of objects Mule stores in the in-memory buffer. The more objects you save in memory, the better performance you get by avoiding writing to disk,
+
For example, you can set a buffer size of 100 objects in memory for a query from the SalesForce Connector:
+
[source,xml,linenums]
----
<sfdc:query query="dsql:...">
  <ee:repeatable-file-store-iterable inMemoryObjects="100"/>
</sfdc:query>
----
+
This interface uses the Kryo framework to serialize objects so it can write them to your disk. +
Although Kryo serializer allows Mule to serialize objects that the JVM cannot serialize by default, some things can’t be serialized. It's recommended to keep your objects simple.
// COMBAK: More info around serializing objects ?
+
[NOTE]
--
This option is only available on Mule EE
--

=== Repeatable In-Memory Iterable

:: This configuration is the default for Mule Runtime Community Edition. +
It uses a default configured buffer size of 500 Objects. If the query result is larger than that, the buffer is expanded to a default increment size of 100 objects until it reaches the configured maximum buffer size. If the stream exceeds this limit, the application fails. +
You can customize the initial size of the buffer, the rate at which the buffer increases, and the maximum buffer size.
+
For example, this configuration would set an in-memory buffer of 100 objects, that increments per 100 objects and allow a maximum size of 500 objects.
+
[source,xml,linenums]
----
<sfdc:query query="dsql:...">
  <repeatable-in-memory-iterable
    initialBufferSize="100"
    bufferSizeIncrement="100"
    maxBufferSize="500" />
</sfdc:query>
----


== See Also

* link:/mule-user-guide/v/4.0/streaming-strategies-reference[Streaming Strategies Reference]
