= DataWeave Language
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping


TODO, TODO, MUCH HAS BEEN STRIPPED OUT FOR REORG

DataWeave language include:

* Function modules for ...
* Pattern matching operators for ...
* Variables, constants, local and global
* Namespaces
* Selectors


== Expressions

DataWeave allows you to put logic in your script using expression values.
All expressions in DataWeave return a value, these can be categorized into:

* <<Functions>>
* <<Selectors>>
* <<Flow Control Expressions>>

=== Functions

An operator applies a specific logic/transformation over a data structure.
Operators can be classified based on their link:https://en.wikipedia.org/wiki/Arity[arity] as Unary, Binary or Ternary. See link:/mule-user-guide/v/4.0/dw-functions-core[DataWeave Core Functions] for a full reference.

.Transform
[source, dataweave, linenums]
----
%dw 2.0
output application/json
---
{
  name: upper "mulesoft"
}
----

.Output
[source,json,linenums]
----
{
  "name": "MULESOFT"
}
----

////
== Operators

TODO
////



== Closer Look at an Example Transformation



.Input
[source, xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<note>
  <to>Tove</to>
  <from>Jani</from>
  <heading>Reminder</heading>
  <body>Don't forget me this weekend!</body>
</note>
----


.Transform
[source, dataweave, linenums]
----
%dw 2.0
output application/json
var date='01-MAR-2015'
---
{
  letter : payload,
  sent : date
}
----



.Output as JSON
[source, json,linenums]
----
{
  "letter": { # <1>
    "note": { # <2>
      "to": "Tove",
      "from": "Jani",
      "heading": "Reminder", # <3>
      "body": "Don't forget me this weekend!"
    }
  },
  "sent": "01-MAR-2015"  # <4>
}
----
<1> The "payload" input is parsed into an Object.
<2> As previously stated, Objects are sequences of key:value pairs. Note how each element name from the XML input is parsed into a key followed by a colon : and then the value.
<3> The value may be a Simple Value, as is the case of the *heading* field, or an object, as is the case in *note* #2.
<4> This value arises from a variable 'date', which is defined in a directive in the DataWeave header.




Note that when you make a transformation from JSON to XML, make sure that the resulting output is valid as an XML file. Specifically, make sure that there's a single parent tag, JSON supports having multiple elements at the highest level while XML does not.

Likewise, whenever you transform from XML to JSON, make sure the resulting output is valid as a JSON file. Specifically, make sure that there are no repeated keys inside the same parent. XML supports having this but JSON doesn't.


== Next Steps

* For a reference about all of the operators that are available for the `using` operator, see link:/mule-user-guide/v/4.0/dw-functions-core[DataWeave Core Functions]
* For a listing and details about all of the types you can use, see link:/mule-user-guide/v/4.0/dataweave-types[DataWeave Types]
* For details on the different formats you can process with DataWeave and the parameters you can configure for each format, see link:/mule-user-guide/v/4.0/dataweave-formats[DataWeave Formats]
* For details on how you can select certain components of the incoming message, see link:/mule-user-guide/v/4.0/dataweave-selectors[DataWeave Selectors]

* link:/mule-user-guide/v/4.0/dataweave-import-task[To Import DataWeave Modules]
* link:/mule-user-guide/v/4.0/dataweave-create-module-task[To Create a DataWeave Module]

* View complete example projects that use DataWeave in the link:https://www.mulesoft.com/exchange#!/?filters=DataWeave&sortBy=rank[Anypoint Exchange]



== See Also

* link:/mule-user-guide/v/4.0/dataweave-cookbook[DataWeave Cookbook]


----
== DataWeave Expression Essentials

It's important to know that DataWeave has not always been the _de facto_ expression language Mule uses. Prior to version 4.0.0, the Mule Expression Language (MEL) was used for most needs, whilst DataWeave was reserved for only transforming data.

[TIP]
====
For the simple use case of extracting a value from the Mule event, DataWeave syntax remains identical to that of MEL, so you might find that some scripts from older versions work in Mule 4 without any changes, even though they're technically being processed via a different language engine.

If you still need to use MEL, you can include it to your projects by adding the compatibility package.
====

DataWeave expressions are written according to the following format: `#[expression]`.

DataWeave expressions are deeply influenced by their context. Metadata about input and output data – its format, structure, etc – shapes the behavior of your transformation. Understanding the *Mule event object structure* is therefore critical. If you are not already familiar with the Mule Event object structure, read the link:/mule-user-guide/v/4.0/mule-concepts[Mule concepts] document.

The language allows you to specify custom properties in a header section. This part of the expression is *optional* because these properties default to whatever fits the context of the data being processed within the application.

////
If you're already familiar with Java, learning DataWeave is not difficult. That said, it's important to comprehend some Mule-specific details _before_ you learn how to apply DataWeave expressions in your application.

. *Understand the Mule message structure.* Because you use DataWeave to act upon the contents of a Mule event object (payload, attributes and variables), you first need to understand the basic structure of the Mule event. If you are not already familiar with it, read about the link:/mule-user-guide/v/4.0/mule-concepts[Mule concepts].

. *Understand how to see the contents of the Mule event.* To be able to act upon it, you need to be able to figure out what type of data it contains. Is the payload an array? Are there any variables? What properties exist? The link:/getting-started/mule-message[Mule Message Tutorial] describes the tools you can use to see inside the message, so that you know how to use DataWeave expressions to manipulate the data.

+
////

[TIP]
Note that as of Mule 4.0.0, the Mule event structure is radically different, making it a lot simpler to reference its parts.

== Using DataWeave

Based on information that's extracted from the Mule event and environment properties at runtime, Mule evaluates expressions to complete different types of tasks:

* *Extract* information: 
** `#[payload]`
** `#[attributes.propertyName]`
** `#[myVariableName]`
** `#[sizeOf(payload.shoppingCart.items)]`
+
[TIP]
For a full reference about how to extract different values with DataWeave, see link:/mule-user-guide/v/4.0/dataweave-cookbook-extract-data[DataWeave cookbook - Extract Data].

* *Evaluate* conditions:
** `#[payload.age > 21]`
** `#[attributes.locale  ==  'en_us']`
+
The example below evaluates part of the payload to forward requests to different flows.
+
[source, xml, linenums]
----
<choice>
  <when expression="#[payload.purchaseType == 'book']">
    <flow-ref name="flow1"/>
  </when>
  <when expression="#[payload.purchaseType == 'mp3']">
   <flow-ref name="flow2"/>
  </when>
</choice>
----

* *Transform* the message.
** `#[payload: shirtSizeArray ++ "XXL" ]`
** `#[payload.name: upper(payload.name)]`
+
The example below cycles through an array of objects, upper cases the values in "size" for each object. DataWeave then filters only objects where the "count" value is greater than 0.
+
[source,DataWeave, linenums]
----
%dw 2.0
output application/json
---
(payload map (value, index) -> {
    size: upper(value.size),
    count: value.count
  }
) filter $.count > 0
----

== The Transform Component

The *Transform* component allows you to use the language to query and transform data through DataWeave. Any mappings you perform through the graphical interface are also expressed in DataWeave code in real-time and vice-versa.
////
* link:https://docs.mulesoft.com/anypoint-studio/v/7/using-dataweave-in-studio[Graphically map] fields by dragging one attribute to another
* Implement this component through link:/mule-user-guide/v/4.0/transform-dataweave-xml-reference[XML]
////
== Auto-Complete

If you are configuring a field that supports expressions and need help with syntax, you can access DataWeave suggestions by one of two methods.

* Place your cursor inside the brackets in a field that has `#[]` pre-populated for you, then press Ctrl + Space Bar. If you are using Design Center, you do not need to add your code between the brackets.

* Enter `#[` to open a new DataWeave expression and display suggestions, as shown below.
+
image:auto_complete.png[auto_complete]
+
[NOTE]
Note that the autocomplete functionality described here works in the *Visual Editor only*. Although Studio's XML tab does offer some autocomplete options, the suggestions there are limited by Eclipse and are not based on DataSense or DataWeave.


== Additional Tips

* DataWeave performs link:http://en.wikipedia.org/wiki/Type_coercion[type coercion] at runtime. 
* When writing in Studio's XML editor, you cannot use double quotes to express String literals, because DataWeave expressions already appear enclosed in double quotes in configuration files. Instead, you can either: +
** use single quotes                   `('expression')`
** escape quotes with &quot;      `(&quot;expression&quot;)`
** escape quotes with \u0027      `(\u0027expression\u0027)`
+
If you're coding in Studio's DataWeave visual editor, Studio transforms double quotes into escaped quotes `(&quot;) `in the XML view.
----

----
== Closer Look at an Example Transformation

.Input
[source, xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<note>
  <to>Tove</to>
  <from>Jani</from>
  <heading>Reminder</heading>
  <body>Don't forget me this weekend!</body>
</note>
----

.Transform
[source, dataweave, linenums]
----
%dw 2.0
output application/json
var date='01-MAR-2015'
---
{
  letter : payload,
  sent : date
}
----



.Output as JSON
[source, json,linenums]
----
{
  "letter": { # <1>
    "note": { # <2>
      "to": "Tove",
      "from": "Jani",
      "heading": "Reminder", # <3>
      "body": "Don't forget me this weekend!"
    }
  },
  "sent": "01-MAR-2015"  # <4>
}
----
<1> The "payload" input is parsed into an Object.
<2> As previously stated, Objects are sequences of key:value pairs. Note how each element name from the XML input is parsed into a key followed by a colon : and then the value.
<3> The value may be a Simple Value, as is the case of the *heading* field, or an object, as is the case in *note* #2.
<4> This value arises from a variable 'date', which is defined in a directive in the DataWeave header.


Note that when you create a transformation from JSON to XML, you must make sure that the resulting output is valid as an XML file. Specifically, make sure that there is a single parent tag. Though JSON supports having multiple elements at the highest level, XML does not.

Similarly, whenever you transform from XML to JSON, make sure the resulting output is valid as a JSON file. Specifically, make sure that there are no repeated keys inside the same parent. XML supports duplicate keys, but JSON does not.
----
