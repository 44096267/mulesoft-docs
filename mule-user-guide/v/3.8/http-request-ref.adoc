= HTTP Request Configuration Reference
:keywords: anypoint studio, esb, connectors, http, https, http headers, query parameters, rest, raml

A typical use of the HTTP connector request operation is to consume an external web service using the GET method. After sending the request, the connector receives the response and passes it to the next element in the flow. You can configure the following types of authentication:

* Basic
* OAuth
* NT LAN Manager (NTLM)
* Digest

The required minimum setting for the request operation is a host URI, which can include a path. GET is the default method. The following example shows a minimal configuration in XML:

[source, xml, linenums]
----
<http:request-config name="HTTP_Request_configuration" doc:name="HTTP Request configuration" doc:id="8f2d4125-129d-4f8b-9ead-4af16034b359" >
	<http:request-connection host="http://jsonplaceholder.typicode.com/users" />
</http:request-config>
...
<http:request config-ref="HTTP_Request_configuration" method="GET" path="/" doc:name="Request" doc:id="df8c288e-1fc1-456f-b188-14a1fbf609ae" />
----

By default, GET and OPTIONS methods do not send the payload in the request. The body of the HTTP request is empty. The other methods send the message payload as the body of your request.

== Mapping Between Mule Messages and HTTP Requests

An app generates a Mule message when executing an HTTP Request operation. 

=== HTTP Request Body

The connector sends the Mule message payload as the HTTP request body except under the following conditions:

* The payload consists of a map of keys and values
* The message has outbound attachments

=== Payload Consisting of a Map

When the message payload is a map, the connector generates an HTTP request with the header Content-Type:application/x-www-form-urlencoded. The keys and values of the map in the payload are converted into form parameter keys and values in the body of the HTTP request.

=== Message Having Outbound Attachments

When the message contains outbound attachments, the connector generates an HTTP Request with the header Content-Type:multipart/form-data. The payload of the Mule message is ignored. Each attachment in the message is converted into a part of the HTTP Request body. If you want to create a different multipart request, set the Content-Type header to a different value by adding custom parameters.

=== HTTP Headers

Outbound attributes in the Mule message, if there are any, are added as HTTP request headers to the request. You can also add headers explicitly during connector configuration. 

By default, the HTTP connector limits the HTTP request header section size (request line + headers) to 8191 bytes maximum. To increase the number of bytes in the allowed header section, set `mule.http.headerSectionSize` in the wrapper.conf file or on the command line when you start Mule runtime as follows:

`./mule -M-Dmule.http.headerSectionSize=16000`


== Adding Custom Parameters

In addition to the body of the request, you can configure the following things in the request:

* Headers
* Query parameters
* URI parameters

You can configure a map of multiple headers or parameters.

You can also include form parameters in the payload to send with the request. To add an attachment to a request, add a building block to the flow.

=== Query Parameters

In General > Request, click *Query Parameters*, and + to add a parameter to a request. Type a name and value for the parameter or use a DataWeave expression to define the name and value.

=== URI Parameters

You configure a URI parameter when you want to use a placeholder in the URI, such as `/customer/{customerId}` that starts your app.

To configure a URI parameter, for example, do the following things:

* In General, type the placeholder enclosed in curly brackets in Path.  
* Select URI Parameters, click +, and enter a name and value. For example, enter *customerId* and *20* as the name and value.

image::http-mule4-uriparams.png[customerId 20]

Alternatively, you can use DataWeave expressions in the name and value fields.

When the app runs, you can perform a GET request by going to `+http://www.example.com/customer/20+`.

=== Headers

Select Headers to add headers to the request. For example, add header names HeaderName1 and HeaderName2. Add header values HeaderValue1 and HeaderValue2. You can use DataWeave expressions, referencing headers as `attributes.headers`.

=== Dynamic Parameters and Headers.

If at design time, you don't know how many query parameters or headers a request might need, use DataWeave and a variable map to dynamically assign parameters or headers to the request.

For example, you first create a variable named `customMap`. Next, you assign the variable a map of values using DataWeave:

`{customMap:attributes.queryParams}`

To set URI parameters dynamically, use a DataWeave expression that returns a map of the parameters. For example:

* Set Path to `/test/{p1}/{p2}`
* URI Parameter names: p1 and p2
* URI Parameter value: `{customMap:attributes.uriParams}` and `{customMap:attributes.uriParams}`

The connector resolves parameters for each request, evaluating DataWeave expressions in the context of the current message, in the order specified in the request. If the same parameter is defined more than once, the latest value is used.

=== Sending Form Parameters in a POST Request

To send parameters in a POST request:

* In General > Request, select the POST method.
* In Body, construct the payload of the Mule message as a map with the names and the values of the parameters to send. For example:
+
`{payload.'key1'='value1', payload.'key2'='value2'}`

A POST request is sent to the host location you specify with `Content-Type: application/x-www-form-urlencoded`, and the body is "`key1=value1&key2=value2`".

== Mapping Between HTTP Responses and Mule Messages

An HTTP response is mapped to the Mule message similar to the way that the HTTP request is mapped to a Mule message. The following elements don't apply to HTTP responses:

* Query parameters
* URI parameters
* All inbound properties related to the HTTP request URI

In addition, the HTTP request operation adds the following attributes to the Mule message when receiving a response: +

* `attributes.statusCode`: Status code of the HTTP response
* `attributes.reasonPhrasae`: Reason phrase of the HTTP response

=== Disabling HTTP Response Body Parsing

By default, the request operation does not parse the message. In General > Response, you can manage parsing by selecting to parse, not to parse, or to execute an expression.

== Round-Robin Requests

The request operation connects to configured hosts using round robin DNS. Mule Runtime resolves all IP addresses associated to the specified host and distributes the requests across all returned IPs improving load balancing for the host.

When connecting to resources that require authentication, the external service needs to replicate session information between IP addresses under the host of your service. Otherwise, your requests might get rejected for being unauthorized.

When your external resource does not handle _sticky sessions_ you need to add the service host name to the `mule.http.disableRoundRobin` system property when starting the Mule Runtime:

[source,Command,linenums]
----
./mule -M-Dmule.http.disableRoundRobin=serverhostname.com
----

When configured in this way, the request does not use round robin DNS round robin when connecting to configured host.

== HTTP Response Validation

When the HTTP Request Connector receives an HTTP response, it validates the response through its status code. By default, it throws an error when the status code is higher or equal to 400. This means that if the server returns a 404 (Resource Not Found) or a 500 (Internal Server Error) the HTTP Request Connector fails and the exception strategy of the flow it is called from is triggered.

You can change the set of valid HTTP response codes by configuring General > Response > Response Validator. 

* *None: * No validation occurs.
* *Expression: * Validation occurs per the DataWeave expression you construct.
* *Success Status Code Validator: * All the status codes defined within this element are considered valid; the request throws an exception for any other status code.
* *Failure* *Status Code Validator: * All the status codes defined within this element are considered invalid and an exception is thrown; the request is considered valid with any other status code.   

To set a list of status codes accepted as successful responses, do the following:

. In General > Response > Response Validator, select Success Status Code Validator.
. In *Values*, enter the list of accepted status codes, separated by commas: *200,201*.

If the HTTP response has any other status value, it's considered a failure and raises an exception.

A range of failure status codes is defined by two dots *..*. Any value between 500 and 599 is considered a failure and raises an exception. If the HTTP response has any other status value, it's considered a success.

== Configuring Source and Target

By default, the body of a request is taken from the `\#[payload]` of the incoming Mule message and the response is sent onwards as the `#[payload]` of the output Mule message. You can change this default behavior through the General > Request > Body and General > Output > Target Variable attributes.Use this attribute to specify a place other than payload for the output data, such as a variable.

== Configuring Streaming

By default, if the type of the payload is a stream, streaming is used to send the request. You can change this default behavior. Select General > Request > Request Streaming with one of the following values:

* *AUTO* (default): The behavior depends on the payload type: if the payload is an InputStream, then streaming is enabled; otherwise it is disabled.
* *ALWAYS*: Always enable streaming regardless of the payload type.
* *NEVER*: Never stream, even if the payload is a stream.

When streaming, the request does not contain the `Content-Length` header. It contains the `Transfer-Encoding` header and sends the body in chunks until the stream is fully consumed.


== Sending Multipart Requests

To send a multipart request (for example to upload a file in a POST request), outbound attachments should be set in the Mule message. When the message has attachments, a multipart request is sent where each part is an attachment. In this case the payload is ignored.

You can use Attachment transformers to add attachments to your message:

image:http-request-connector-99015.png[use attachment transformers]

This sends a POST request with `ContentType: multipart/form-data` and with two parts: one with the first attachment, the other with the second.

If the response is a multipart response, then the parts map as inbound attachments in the Mule message, and the payload is null.

== HTTPS Protocol Configuration

You can send your requests through HTTPS protocol by simply setting the protocol attribute to HTTPS . This makes the HTTP Request Connector use the default JVM values for the HTTPS connection, which  likely already includes a trust store with certificates for all the major certifying authorities.

In the connector's Global Configuration Element, on the *General* tab, select the *HTTPS* radio button to select the Protocol.

If you want to use a different set of HTTPS certificates, you can customize them by setting the link:/mule-user-guide/v/3.8/tls-configuration[TLS configuration] in the HTTP Request Connector's global configuration element. You can also create a separate TLS global element and reference it through your HTTP Connector. +

. In the connector's Global Configuration Element, in the *General* tab, select the *HTTPS* radio button to select the Protocol.
. Select the *TLS/SSL tab*
. Either:

** Select the *Use TLS Config* option and provide your credentials in the available fields.
** Or select the *Use Global TLS Config* option, then select an existing configuration or create a new one by clicking the green plus sign next to the selection box.

[NOTE]
--
If you need to temporarily disable certificate validations, you can select the _Insecure_ option. This causes your Mule application to accept all certificates from an SSL endpoint without validating them in the flow.

Remember to un-check it back when you finally deploy your application.
--

....
[tab,title="XML Editor"]
....
You can add your link:/mule-user-guide/v/3.8/tls-configuration[TLS] credentials as a child element of the `http:request-config` element:

[source, xml, linenums]
----
<http:request-config name="HTTP_Request_Configuration" host="example.com" port="8081" protocol="HTTPS" doc:name="HTTP_Request_Configuration"/>
        <tls:context>
            <tls:trust-store path="your_truststore_path" password="your_truststore_password"/>
            <tls:key-store path="your_keystore_path" password="your_keystore_path" keyPassword="your_keystore_keypass"/>
        </tls:context>
</http:request-config>
 
<flow name="test_flow">
    ...
    <http:request path="test" method="POST"  config-ref="HTTP_Request_Configuration" />
</flow>
----

The above example sends a POST request to +http://www.example.com/test+, encrypted with the provided HTTPS settings.

You can also add your link:/mule-user-guide/v/3.8/tls-configuration[TLS] credentials in a separate construct, outside your `http:request-config` element. In that case, you must name your `tls:context` and add a `tlsContext-ref` attribute in your `http:request-config`.

[source, xml, linenums]
----
<http:request-config name="HTTP_Request_Configuration" host="example.com" port="8081" tlsContext-ref="My-TLS_Context" protocol="HTTPS" doc:name="HTTP_Request_Configuration"/>
         
<tls:context name="My-TLS_Context" doc:name="My-TLS_Context">
        <tls:trust-store path="your_truststore_path" password="your_truststore_password"/>
        <tls:key-store path="your_keystore_path" password="your_keystore_path" keyPassword="your_keystore_keypass"/>
</tls:context>
 
<flow name="test_flow">
    ...
    <http:request path="test" method="POST"  config-ref="HTTP_Request_Configuration" />
</flow>
----

[NOTE]
--
If you need to temporarily disable certificate validations, you can set `<tls:trust-store insecure="true"/>` inside the `<tls:context>` tag. This causes your Mule application to accept all certificates from an SSL endpoint without validating them in the flow.

Remember to set this value to _false_ before deploying your application, or simply remove the tag, since false is its default value.
--
....
------

== Other Attributes

Other attributes in this connector allow you to set up more advanced functionality: response timeout, if redirects aree followed and if responses are parsed.

[tabs]
------
[tab,title="Studio Visual Editor"]
....
These attributes are available in the *Advanced* tab in the connectors properties editor.

[%header,cols="2*"]
|===
|Attribute |Description
|Response Timeout |Specifies the time in milliseconds after which, if no response is received, the request is no longer attempted.
|Parse Response |If true, it parses the response if you receive multipart responses. If set to false, no parsing is done and the raw contents of the response are placed in the payload. By default it's set to true.
|Follow Redirects |Defines whether redirects are followed or not. This is set to true by default
|Use Cookies | When checked, gathers cookies from each response it receives and then send them on subsequent requests.
|===
....
[tab,title="XML Editor"]
....
[%header,cols="2*"]
|===
|Attribute |Description
|responseTimeout |Specifies the time in milliseconds after which, if no response is received, the request is no longer  attempted.
|parseResponse |If true, it parses the response if you receive multipart responses. If set to false, no parsing is done and the raw contents of the response are placed in the payload. This is set to true by default.
|followRedirects |Defines whether redirects are followed or not. This is set to true by default.
|enableCookies |When set to `true`, this attribute gathers cookies from each response it receives, and then send them on subsequent requests.
|===

For example:

[source, xml, linenums]
----
<http:request-config name="HTTP_Request_Configuration" host="example.com" port="8081" doc:name="HTTP_Request_Configuration"/>
  
<flow name="test_flow">        ...
     <http:request config-ref="HTTP_Request_Configuration" path="test" method="GET" followRedirects="true" parseResponse="false" enableCookies="true" responseTimeout="10000" />
</flow>
----
....
------

== See Also


