= APIkit Reference
:keywords: apikit, rest, console, load balancer, configuring path

APIkit supports RAML 1.0 and 0.8 versions as described in the link:/release-notes/apikit-release-notes[release notes]. APIkit projects can run onsite or on CloudHub. To get started using APIkit in Anypoint Studio, do one of the following:

* From Project Wizard import a RAML definition from one of the following sources:
** Local file system
** Anypoint Platform
** A remote location

* Create the RAML file within an existing Studio project (called a backend-first APIkit design).

When you import an API from Anypoint Platform, APIkit includes any RAML dependencies in the Studio project. You can then keep the API in both locations in sync by pushing or pulling changes from one to the other.

APIkit generates the following things when you import or reference a RAML that declares a baseURI:

// Is Jetty supported?

* A main flow with an HTTP Listener
+
After importation, you can replace the HTTP Listener with a Jetty endpoint.
+
* An APIkit Router
* Error handling

[source,xml,linenums]
----
<flow name="api-main">

</flow>
----

Included in the project are backend flows containing REST resource-action mappings. You can simulate calls to the API using API Console.

After simulating calls to a RAML-based API using API Console, and improving or changing behavior, you alter the backend flows to act upon real resources with real data.

== Configuring the Path for Deployment on CloudHub

CloudHub requires a unique application name regardless of the region where you deploy the API. You can, for example, add the region name to the application name to ensure uniqueness. For example:

`test-customers-eu`

`test-customers-na`

By default, APIkit adds a base path `/api` to each API. The final URL of the APIs deployed on CloudHub is:

`+http://test-customers.eu.cloudhub.io/api/customers+`

`+http://acceptance-customer.eu.cloudhub.io/api/customers+`

=== Running Multiple Versions of the Same API

To run multiple versions of the same API simultaneously, deploy each API implementation using an unique name. For example, add the version number for uniqueness:

`test-customer-v1.eu.cloudhub.io`

`test-customer-v2.eu.cloudhub.io`

The final URL of the APIs deployed on CloudHub is:

`+http://test-customers-v1.eu.cloudhub.io/api/customers+`

`+http://acceptance-customers-v1.eu.cloudhub.io/api/customers+`

Dropping the environment prefix for production is a MuleSoft best practice. For example:

`http://customers-v1.eu.cloudhub.io/api/customers`

You can setup desired URLs for each application on CloudHub by using a custom load balancer. For instance, you can configure `http://api.yourcompany.com/customer/v1` to point to this URL:

http://customers-v1.eu.cloudhub.io/api/customers

== Configuring the Path for Deployment Onsite

As mentioned, by default, APIkit adds a base path `/api` to each API. A different application deployed on the same server attempts to listen on the same context, for example `+http://server:port/api/+`, which causes a conflict.

To avoid such a conflict, configure each Mule application using a different base path. For example:

`/api/customers`

`/api/products`

If multiple versions of the same application need to run on the same server, add a version designator to the base path. For example:

`/api/customers/v1`

`/api/customer/v1`

Because each server belongs to a different environment, there is no need to include the environment, such as `/test` or `/dev`, in the base path.

Avoid hard-coding URLs in base path. Use different property files for different deployments:

image::apikit-using-7d817.png[apikit-using-7d817.png]

You can configure a custom load balancer to adjust URLs. For example, `http://api.yourcompany.com/customer/v1` can point to `+http://server:port/api/customer/v1+`.

== Changing APIkit Elements

Under the following conditions, you need to customize the mapping of RAML resources and actions:

* You generated backend flows as part of the backend-first design process.
* You renamed a backend flow.

Customizing the mapping of RAML resources and actions is described in the backend-first design process.

== Backend-First Design Process

If you create a new Studio project without specifying a RAML file, and you check the Add API Components checkbox, APIkit generates a skeletal RAML file and XML config that includes the following things:

* HTTP Listener configuration
* APIkit Router component
* Error handling flows

After adding the RAML content, you can use API Console to simulate the API.

=== Adding APIkit to an Existing Design

You add APIkit components to an existing design, for example a legacy project that you want to modernize using RAML and APIkit, by creating the RAML code within Studio as follows:

*RAML-based API*

* Define the RAML.
* Create a main flow, or use an existing one, that includes an *HTTP Listener* and *APIkit Router*.
* Generate backend flows.
* Add a reference to error handling in the main flow.
* Add an apikit:console component.

The generated backend flows contain the core logic of the API, the REST resource-action pairing.

=== Creating a Main Flow

Within the APIkit project, build a flow. Drag the following components from the Mule palette:

* An HTTP (or Jetty) Listener
* An APIkit Router

image::apikit-using-ea7ad.png[apikit-using-ea7ad]


=== Generating REST Backend Flows

When you create a RAML in Studio, generating backend flows is optional. Error handling is generated for a RAML-based API. You need to reference generated flows from the main flow. This procedure assumes you have already created a main flow.

To generate backend flows, including reference exception strategies: 

. In the *Package Explorer*, right-click the project name.
. Select *Mule* > *Generate Flows from RAML*
+
The backend flows appear below the main flow.
+
image::apikit-tutorial-ce60c.png[]

// Replacement for the exception strategy?

```
. Expand the *Error handling* section in the main flow.
. Drag a *Reference Exception Strategy* component from the Mule palette to the Error handling section.
. On the Configuration.xml tab, add link:/apikit/apikit-basic-anatomy#raml-based-exception-strategy-mappings[exception strategy mappings] to the project right after the last `</flow>` tag.
```

=== Mapping RAML Resources to Actions

As part of the backend-first design process, you map RAML resources to actions as shown in the following procedure. This procedure assumes you have generated backend flows.

To map resources to actions:

. Click the APIkit Router to open the *Properties Editor*. In *Router configuration*, click image:Add-16x16.png[Add-16x16].
+
The *Global Element Properties* wizard appears.
+
image::apikit-using-9bea1.png[apikit-using-9bea1]
+
. Browse to the RAML file you created within Studio.
. In Mappings, click image:Add-16x16.png[Add-16x16] to create a new mapping.
+
The *New Mapping* dialog appears.
. Use the drop-down to map the resources to actions.
+
* In the Resource drop-down, select `/sales`.
+
* In the Action drop-down, select `Post`.
+
* In the Flow drop-down, select the flow that contains the post action:
+
`post:/sales:application/json:Router`
+
Click *OK*.
+
image::apikit-using-ab251.png[apikit-using-ab251]
+
. Repeat the previous step for each resource-action pairing in the API.

== Using a Load Balancer

If your API implementation involves putting a load balancer in front of your APIkit application, configure the load balancer to redirect URLs that reference the `baseUri` of the application directly. If the load balancer does not redirect URLs, any calls that reach the load balancer looking for the application do not reach their destination. For example, you deploy an APIkit application to `myapp.mycompany.com`, and then add a load balancer at `www.exampleloadbalancer.com`. A call to the API arrives at `www.exampleloadbalancer.com` and the load balancer redirects the call to `myapp.mycompany.com` to get a response.

When using a load balance, set the `keepRamlBaseUri` to true to put the URL of a proxy in the baseUri property.

== See Also

* link:/apikit/apikit-tutorial-jsonplaceholder[REST tutorial]
