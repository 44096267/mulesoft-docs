= Example: To send messages across different applications
:keywords: VM, queues, connector, publish, listen, response, domain, across applications
:toc:
:toc-title:

toc::[]

You can also send messages across applications by leveraging Mule domains. Unlike Mule 3.x in which domains were reserved to only a handful of supported components, in Mule 4 every connector supports being placed in a domain.

So, you can create a VM configuration in a domain like in this example:

[source, xml]
----
<mule-domain xmlns="http://www.mulesoft.org/schema/mule/domain"
             xmlns:vm="http://www.mulesoft.org/schema/mule/vm"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://www.mulesoft.org/schema/mule/vm http://www.mulesoft.org/schema/mule/vm/current/mule-vm.xsd
               http://www.mulesoft.org/schema/mule/domain http://www.mulesoft.org/schema/mule/domain/current/mule-domain.xsd">

    <vm:config name="sharedVMConfig" />

</mule-domain>
----

Then place a listener in an application of the same domain:

[source, xml]
----
<flow name="crossAppListener">
	<vm:listener queueName="sharedQueue" config-ref="sharedVMConfig" />
	<logger />
</flow>
----

And the publish messages from a second application, also of the same domain:

[source, xml]
----
<flow name="crossAppRequester">
	<vm:publish queueName="sharedQueue" config-ref="sharedVMConfig" />
</flow>
----

Notice how both the listener and publisher both point to the same configuration defined in the domain.
