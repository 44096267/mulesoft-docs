= Database Connector XML Reference

The Database connector has a single configuration that accommodates child elements that define providers. For example:

* `<db:derby-connection url="jdbc:derby:muleEmbeddedDB;create=true">`
* `<db:generic-connection url="jdbc:derby:muleEmbeddedDB;create=true" driverClassName="org.apache.derby.jdbc.EmbeddedDriver"/>`
* `<db:my-sql-connection  host="0.0.0.0" port="3306" user="Max" password="POWERS" database="someSchema"/>`
* `<db:derby-connection database="target/muleEmbeddedDB" create="true">`
* `<db:oracle-connection host="192.168.99.100" port="1521" instance="xe" user="system" password="oracle" />`

The Database Connector Technical Reference describes exclusive and common parameters for each provider. A child element of the provider element defines custom data types. For example:

[source,xml,linenums]
----
<db:config name="dbConfig">
   <db:derby-connection url="jdbc:derby:muleEmbeddedDB;create=true">
       <db:custom-data-types>
           <!-- Derby uses JAVA_OBJECT for UDT-->
           <db:custom-data-type typeName="CONTACT_DETAILS" id="2000"/>
       </db:custom-data-types>
   </db:derby-connection>
</db:config>
----

== Global Data Source Reference

This connection references a data source typically defined as a Spring bean. For example:

[source,xml,linenums]
----
<spring:bean id="jdbcDataSource" class="org.enhydra.jdbc.standard.StandardDataSource" destroy-method="shutdown">
  <spring:property name="driverName" value="org.apache.derby.jdbc.EmbeddedDriver"/>
  <spring:property name="url" value="jdbc:derby:muleEmbeddedDB;create=true"/>
</spring:bean>

<db:config name="dbConfig">
   <db:data-source-connection dataSourceRef="jdbcDataSource" />
</db:config>
----

== Operations

The database connector supports the following SQL queries:

* Select
* Insert
* Update
* Delete

=== Select Operation

The Select operation returns one of the following types, depending on streaming:

* List of Map<String, Object> (no streaming)
* Iterator

If the results are streamed, the connection and its underlying resources are not released until the returned stream is fully consumed or the flow ends.

The following example shows the syntax of a select operation:

[source,xml,linenums]
----
<db:select maxRows="2">
  <db:sql>select * from PLANET order by ID</db:sql>
</db:select>
----

=== Insert Operation

The following example shows the syntax of an insert operation:

[source,xml,linenums]
----
<flow name="insertParameterized">
  <db:insert>
    <db:sql>INSERT INTO PLANET(POSITION, NAME) VALUES (777, :name)</db:sql>
      <db:input-parameters>
         <db:input-parameter key="name" value="#[payload]"/>
     </db:input-parameters>
  </db:insert>
</flow>
----

=== Update Operation

The following example shows the syntax of an update operation:

[source,xml,linenums]
----
<flow name="updateParameterized">
  <db:update>
    <db:sql>update PLANET set NAME= :name where NAME='Mars'</db:sql>
      <db:input-parameters>
        <db:input-parameter key="name" value="#[payload]"/>
    </db:input-parameters>
  </db:update>
</flow>
----

=== Delete Operation

The following example shows the syntax of a delete operation.

[source,xml,linenums]
----
<flow name="deleteParameterized">
  <db:delete>
    <db:sql>DELETE FROM PLANET WHERE name = :name</db:sql>
      <db:input-parameters>
        <db:input-parameter key="name" value="#[payload]"/>
    </db:input-parameters>
  </db:delete>
</flow>
----

=== Dynamic Queries

The connector supports dynamic queries:

[source,xml,linenums]
----
<flow name="dynamicQuery">
  <set-variable variableName="tableName" value="PLANET"/>
  <db:select>
    <db:sql>select * from #[tableName] order by ID</db:sql>
  </db:select>
</flow>
----

Do _not_ use dynamic queries to define parameters. Doing so makes the code vulnerable to SQL injection. Instead, use parametrized queries.

=== Parametrized Queries

Queries can include parameters. Those parameters can be referenced and set by name. This has two advantages over doing it with dynamic queries:

* Immunity from SQL injection attacks
* Performance

For example:

[source,xml,linenums]
----
<flow name="selectParameterizedQuery">
  <db:select>
    <db:sql>select * from Planet where name = :name</db:sql>
      <db:input-parameters>
        <db:input-parameter key="name" value="#[payload]"/>
      </db:input-parameters>
  </db:select>
</flow>
----

=== Hybrid Queries

You can mix dynamic and parametrized queries. For example:

[source,xml,linenums]
----
<flow name="selectHybridQuery">
  <set-variable variableName="tableName" value="PLANET"/>
  <db:select>
    <db:sql>select * from #[tableName] where name = :name</db:sql>
      <db:input-parameters>
        <db:input-parameter key="name" value="#[payload]"/>
      </db:input-parameters>
  </db:select>
</flow>
----

=== Query Templates

Using a template, you can reuse a query to select, insert, update, or delete data. Use a template to reuse an entire query or part of it. For example, to reuse an entire query:

[source,xml,linenums]
----
<db:query name="selectQuery">
   <db:sql>select * from Planet where name = :name</db:sql>
   <db:input-parameters>
       <db:input-parameter key="name" value="#[payload]" type="VARCHAR"/>
   </db:input-parameters>
</db:query>
<flow name="selectParameterizedQuery">
   <db:select config-ref="dbConfig" template="selectQuery" />
</flow>
----

To partially define a query based on a template:

[source,xml,linenums]
----
<db:query name="namedParamsQueryTemplate">
   <db:sql>SELECT * FROM PLANET WHERE POSITION = :position and NAME = :name</db:sql>
</db:query>
<flow name="inlineOverriddenParamsByName">
   <db:select template="namedParamsQueryTemplate">
       <db:input-parameters>
           <!-- Note that parameters are in different order-->
           <db:input-parameter key="name" value="Venus"/>
           <db:input-parameter key="position" value="2"/>
       </db:input-parameters>
   </db:select>
</flow>
----

To query the database by referring to a template:

[source,xml,linenums]
----
<db:query name="namedParamsQueryTemplate">
   <db:sql>SELECT * FROM PLANET WHERE POSITION = :position and NAME = :name</db:sql>
</db:query>
<flow name="overriddenParamsByName">
   <db:select template="namedParamsQueryTemplate"/>
</flow>
----

To recursively query the database by referring to a template:

[source,xml,linenums]
----
<db:query name="namedParamsQueryTemplate">
   <db:sql>SELECT * FROM PLANET WHERE POSITION = :position and NAME = :name</db:sql>
   <db:input-parameters>
       <db:input-parameter key="position" value="4"/>
       <db:input-parameter key="name" value="Venus"/>
   </db:input-parameters>
</db:query>
<db:query name="overridenQueryParamByName" template="namedParamsQueryTemplate">
   <db:input-parameters>
       <db:input-parameter key="name" value="Mars"/>
   </db:input-parameters>
</db:query>
<flow name="overriddenParamsByName">
   <db:select template="overridenQueryParamByName"/>
</flow>
----

=== Stored Procedures

This operation accepts input, output, and input-output parameters. 

*Input Parameters Example*

[source,xml,linenums]
----
<flow name="update">
   <db:stored-procedure>
       <db:sql>call updateParamTestType1(:type)</db:sql>
       <db:input-parameters>
           <db:input-parameter key="type" value="#[payload]"/>
       </db:input-parameters>
   </db:stored-procedure>
</flow>
----

*Output Parameters Example*

[source,xml,linenums]
----
<flow name="outParam">
   <db:stored-procedure>
       <db:sql>{ CALL countTestRecords(:count) }</db:sql>
       <db:output-parameters>
           <db:output-parameter key="count"/>
       </db:output-parameters>
   </db:stored-procedure>
</flow>
----

*Input-output Parameters*

[source,xml,linenums]
----
<db:stored-procedure>
   <db:sql>{ call doubleMyInt(:myInt) }</db:sql>
  <db:in-out-parameters>
    <db:in-out-parameter key="myInt" value="#[payload]"/>
  </db:in-out-parameters>
</db:stored-procedure>
----

DataSense is not supported because the return value is unpredictable.


=== Templating

You can reuse a query as shown in the following example:

[source,xml,linenums]
----
<db:stored-procedure name=”split” streaming="true">
   <db:sql>{ call getSplitTestRecords() }</db:sql>
</db:stored-procedure>

<flow name="getResultSet">
   <db:stored-procedure template=”split” />
</flow>
----

== Execute DDL



== Bulk Operations

== Formatting the Output of a Query

The db:output-parameter converts the output of a query from binary to a JDBC or custom type, such as JSON. For example:

`<db:output-parameter paramName="myParam" type="VARCHAR"/>`



== See Also

* Database Connector Technical Reference