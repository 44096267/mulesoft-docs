= Example: To publish and listen messages through the VM Connector
:keywords: VM, queues, connector, publish, listen
:toc:
:toc-title:

toc::[]

In this example we are going to show how to publish a message which is then received in a different flow.

The first step is to define a flow with a `<vm:listener>` as a message source.

[source, xml, linenums]
----
<vm:config name="vm">
    <vm:queues>
        <vm:queue queueName="myQueue" queueType="PERSISTENT" />
    </vm:queues>
</vm:config>

<flow name="listener">
   <vm:listener queueName="myQueue" config-ref="vm" />
   <flow-ref name="yourIntegrationLogic"/>
</flow>
----

The next step is to feed messages into our newly created queue. Suppose we have a flow triggered by an http request with a json payload. We want to extract the body 
attribute of that json object and publish it to the queue:

[source, xml, linenums]
----
    <flow name="publish">
        <http:listener path="/json-here" allowedMethods="POST" config-ref="httpListener" />
        <vm:publish queueName="myQueue">
            <vm:content>#[payload.body]</vm:content>
        </vm:publish>
        <logger/>
    </flow>
----

In this example you can see:

* The publish operation references the queue created in the config
* The content parameter allows to use DataWeave to build the value thatâ€™s going to be sent without having side effects on the message. You could also not specify a content and the entire payload will be sent
* The publish operation is one-way. Once the message has been posted into the queue, the flow continues. The processing on the listening side will happen asynchronously and you receive no notification about its outcome.
* The queueName specified in the publish operation is required to have a matching <vm:listener> element which points to the same queue. If you attempt to publish to a queue for which no listener exists, an error will be raised. This is to prevent message loss by sending messages into a queue nobody is listening to.
